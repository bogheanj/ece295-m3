#+STARTUP: indent
#+TITLE: ECE295 M3 Unit Testing Python Scripts
This repository contains various unit testing scripts for testing the ECE295 subsystems using PyVISA. All scripts assume you have the instruments connected on a LAN network according to the setup in ECE295 SL3. They also assume you have connected the instruments according to the [[file:M3 Test Wiring Diagrams.pdf][M3 wiring diagram]] appropriate for your subsystem. Please refer below for a detailed description of each script.

Each script generates important test information that is printed to the screen. You should capture the output of the screen once your subsystem is fully working. You can do this by using the "~>~" re-direction operator from the command prompt. For example, to capture the output of ~sub-e.py~ to a text file, run the following:
#+BEGIN_SRC
python sub-e.py > output.txt
#+END_SRC
The output of the script(s) used should be included in your M3 unit testing report.

Each script also saves measurement information in various files. Output graphs are written to one or more PNG files in the working directory. The data used to generate the graphs is also saved in one ore more text files using the ~savetxt~ command in Python (refer to documentation on ~savetxt~ if you want to know more about how the file is formatted). Refer to the descriptions below for more information on files generated by the scripts.

NOTE: sometimes if scripts are interrupted while they are running (i.e. using Control-C), it can leave the instruments in an undefined state and running the script may generate an error message. Usually, trying again solves the problem, but if problems persist, you can reset the instrument by turning it on and off.
* Subsystem A
** sub-a-bpf.py
This script measures the frequency response of the bandpass filter preceding the mixer in Subsystem A. It does so by varying the RF input frequency and LO frequency in tandem (with a 1 kHz offset between them by default), so that the amplitudes of the I and Q outputs of Subsystem A are proportional to the frequency response of the filter.

The following variables can be modified as you see fit:
- ~freq~ stores a vector of frequency points to be tested;
- ~offset~ controls the offset between the RF and LO signal frequencies, with the RF frequency being the LO frequency plus the offset; and
- ~input_ampl~ controls the amplitude of wave generator used to excite the ~RF_SIG~ port of Subsystem A. (default: 50 mVpp)

To use the script, run it and follow the instructions. When asked to set the voltage scales of the oscilloscope, it is important that:
1. The signals fill as much of the vertical scale as possible, for maximum resolution;
2. The signals are not clipped; and
3. The scope is triggering cleanly on the signal.
Not satisfying any of these may lead to sub-optimal or erroneous measurements.

The overall conversion gain (in dB) of the subsystem as a function of frequency (i.e. the frequency response of the module) is stored in a file ~bpf.png~. The raw data (frequency, I amplitude, and Q amplitude) is saved in a file ~bpf.txt~.

The resulting frequency response should resemble the plot below. A successful plot should have the correct corner frequencies as well as sufficient gain as specified in the ICD.
#+html: <p align="center"><img src="PNG/bpf.png" width=800/></p>
** sub-a-mixer.py
This script measures the frequency response of the lowpass filter succeeding the mixer in Subsystem A. It does so by varying the RF input frequency while keeping the LO frequency constant. The RF frequency is sinusoid whose frequency is equal to 14 MHz plus the a low-frequency equal to that of a sinusoidal message signal, which effectively generates an upper sideband RF input signal at the output of the oscilloscope's function generator. In this way, the amplitudes of the I and Q outputs of Subsystem A are proportional to the frequency response of the filter.

The following variables can be modified as you see fit:
- ~fm~ stores a vector of message frequency points to be tested;
- ~input_ampl~ controls the amplitude of wave generator used to excite the ~RF_SIG~ port of Subsystem A. (default: 50 mVpp)

The script runs similarly to ~sub-a-bpf.py~ except that the frequency loop is broken into 3 sub-loops to allow you to adjust the voltage scale if necessary, so that you measure with maximum resolution during each sub-loop.

Several graphs are produced:
1. ~lpf.png~ shows the normalized frequency response of the lowpass filter;
2. ~iq_compare.png~ shows the conversion gain of each channel (I, Q) as a function of the message frequency. Ideally, both responses are identical;
3. ~balance_ampl.png~ and ~balance_phase.png~ show the amplitude and phase balance of the I and Q channels. ~balance_ampl.png~ plots the magnitude of $I/Q$, and ideally should be 0 dB for all frequencies ($|I|=|Q|=1$). ~balance_phase.png~ plots the phase difference between the I and Q channel; ideally, Q should lag I by 90 degrees, i.e. $\angle(I/Q) = -90^\circ$.

Representative plots are shown below. The raw data is also stored in a file ~iq.txt~.
#+html: <p align="center"><img src="PNG/lpf.png" width=800/></p>
#+html: <p align="center"><img src="PNG/iq_compare.png" width=800/></p>
#+html: <p align="center"><img src="PNG/balance_ampl.png" width=800/></p>
#+html: <p align="center"><img src="PNG/balance_phase.png" width=800/></p>
* Subsystem B: sub-b.py
The script assesses the behaviour of the demodulator by testing it with SSB signals. The script should not require modification, though the user is free to change the frequency points tested in the vector ~freq~ if desired. *NOTE:* AM demodulation capability is not assessed by this script.

The behaviour of the demodulator is tested by stimulating it with 1 Vpp sinusoidal signals at the I and Q inputs, with the proper phase relationship between them (Q lags I by 90 degrees), to simulate the output of Subsystem A for a single frequency input. The frequency of these signals are varied from 6 kHz - 14 kHz. Assuming a carrier frequency set in the FPGA to be 10 kHz, input signals where the signal frequency is 6-10 kHz will simulate LSB signals (since the input frequency is on the 'lower' side of 10 kHz); when the signal frequency increases beyond 10 kHz, they will simulate USB signals. The job of the demodulator is to recover the appropriate LSB or USB signal depending on the mode.

The script begins by assessing the LSB demodulation capability of the subsystem. The LSB demodulated signal should be connected to CH2 of the oscilloscope. The frequency of the input signals will be swept from 6-14 kHz, which means that between 6-10 kHz, there should be a strong signal output with the same frequency output from the demodulator. Between 10-14 kHz, there should be little or no signal output, since the LSB demodulator should reject USB signals.

Then, the demodulator is placed in USB demodulation mode, and the USB signal is connected to CH1 (a different channel is used so you don't have to keep connecting and disconnecting from the scope). The frequency sweep is repeated, with the opposite behaviour from that described above expected in USB mode (no signal between 6-10 kHz, large signal between 10-14 kHz).

The script produces the following plots, with raw data stored in a file ~demod.txt~.
1. ~demod.png~ shows the LSB and USB outputs as a function of the excitation frequency of the input; and
2. ~rejection.png~ shows the corresponding sideband rejection ratios for each demodulation mode. At least 20 dB of sideband rejection ratio should be achieved by Subsystem B.

A successful demodulator should produce outputs similar to the plots shown below.
#+html: <p align="center"><img src="PNG/demod.png" width=800/></p>
#+html: <p align="center"><img src="PNG/rejection.png" width=800/></p>
* Subsystem C: sub-c.py
This script is intended for testing the remote control of Subsystem C using CAT commands, though it could be adapted to test Subsystem C when controlled from the front panel. It first commands Subsystem C to produce LO output signals in the 8-16 MHz range, checking the signals on the oscilloscope. At the end, it checks control of the TX and RX switch.

Before starting the script, edit the file and change the string variable ~comport~ to be set to the COM port the USB-UART adapter assumes when plugged into the PC you are using (you can check this using the Device Manager). The script will throw an error message if it cannot find the USB-UART adapter.

The script is otherwise self-explanatory, requiring only a connection to the oscilloscope for testing. The frequency variable ~freq~ or the number of points ~N~ can be edited if desired.

Note that during the TX/RX switch test, continuity between the ANT, RX_SIG, and PA_OUT signals must be checked manually, as this is not measured remotely using any instruments.

The script produces the following plots, with raw data stored in ~freq.txt~.
1. ~freq.png~ plots the measured output frequency of both channels as a function of the command frequency issued with the ~FA~ CAT command;
2. ~freq_error.png~ plots the error between the output frequencies produced by each channel, and the command frequency; and
3. ~phase.png~ plots the phase difference between LO_0 and LO_90 as a function of the command frequency. It should be close to $-90^\circ$ regardless of the command frequency.

An operational subsystem should produce plots similar to the plots shown below.
#+html: <p align="center"><img src="PNG/freq.png" width=800/></p>
#+html: <p align="center"><img src="PNG/freq_error.png" width=800/></p>
#+html: <p align="center"><img src="PNG/phase.png" width=800/></p>
* Subsystem E: sub-e.py
This script carries out various tests on the power amplifier and lowpass filter. It does so by exciting the PA with a fixed-amplitude sinusoidal signal. The amplitude of this signal is controlled by a single variable, ~drive_amplitude~, within the script. It should nominally be set to 1.0 (since the ICD specified the input signal must be 1.0 Vpp), but you can override this if you find your subsystem needs a large amplitude signal in order to work.

The script first measures the current consumption of Subsystem E in the idle and active stages (i.e. with no signal and a 14 MHz signal applied to the input of the PA). From this point, you can change the input frequency if you wish (either from the front panel, or permanently, by modifying the script).

It then conducts an FFT analysis with that signal frequency to determine the amplitudes of the first 5 harmonics produced by the PA, including the fundamental frequency. For example, if the input signal is at 14 MHz, harmonics at 14, 28, 42, 56, and 70 MHz are measured. Output power at the fundamental frequency is reported, along with DC-to-RF power conversion efficiency and the total harmonic distortion of the PA. It is recommended you do *not* increase the input frequency past 14 MHz, because it will be difficult to measure the amplitude of the higher-frequency harmonics (especially $n=5$) due to the limited bandwidth of the oscilloscope.

Finally, the frequency response of the PA is measured between 4-20 MHz by default (this can be overridden by changing the ~freq~ vector if you wish).

Several graphs are produced by this script:
1. ~pout_dBW.png~ plots the output power as a function of frequency in dBW (dB-Watts), defined as $10\log_{10}(P_{out})$, where $P_{out}$ is in W. This is a useful plot because the quantity is intrinsically on a logarithmic scale.
2. ~pout.png~ shows the same thing but with the power output expressed in Watts and plotted in a semi-logarithmic axis, if you are more comfortable reading directly in W.
3. ~spectrum.png~ shows the power spectrum of the harmonics in the output in Watts.

Representative plots are shown below. This data is also saved in two text files: ~pout.txt~ and ~spectrum.txt~.
#+html: <p align="center"><img src="PNG/pout_dBW.png" width=800/></p>
#+html: <p align="center"><img src="PNG/pout.png" width=800/></p>
#+html: <p align="center"><img src="PNG/spectrum.png" width=800/></p>


