#+STARTUP: indent
#+TITLE: ECE295 M3 Unit Testing Python Scripts
This repository contains various unit testing scripts for testing the ECE295 subsystems using PyVISA. All scripts assume you have the instruments connected on a LAN network according to the setup in ECE295 SL3. They also assume you have connected the instruments according to the [[file:M3 Test Wiring Diagrams.pdf][M3 wiring diagram]] appropriate for your subsystem. Please refer below for a detailed description of each script.

Each script generates important test information that is printed to the screen. You should capture the output of the screen once your subsystem is fully working. You can do this by using the "~>~" re-direction operator from the command prompt. For example, to capture the output of ~sub-e.py~ to a text file, run the following:
#+BEGIN_SRC
python sub-e.py > output.txt
#+END_SRC

Each script also saves measurement information in various files. Output graphs are written to one or more PNG files in the working directory. The data used to generate the graphs is also saved in one ore more text files using the ~savetxt~ command in Python (refer to documentation on ~savetxt~ if you want to know more about how the file is formatted). Refer to the descriptions below for more information on files generated by the scripts.

NOTE: sometimes if scripts are interrupted while they are running (i.e. using Control-C), it can leave the instruments in an undefined state and running the script may generate an error message. Usually, trying again solves the problem, but if problems persist, you can reset the instrument by turning it on and off.
* Subsystem A
** sub-a-bpf.py
This script measures the frequency response of the bandpass filter preceding the mixer in Subsystem A. It does so by varying the RF input frequency and LO frequency in tandem (with a 1 kHz offset between them by default), so that the amplitudes of the I and Q outputs of Subsystem A are proportional to the frequency response of the filter.

The following variables can be modified as you see fit:
- ~freq~ stores a vector of frequency points to be tested;
- ~offset~ controls the offset between the RF and LO signal frequencies, with the RF frequency being the LO frequency plus the offset; and
- ~input_ampl~ controls the amplitude of wave generator used to excite the ~RF_SIG~ port of Subsystem A. (default: 50 mVpp)

To use the script, run it and follow the instructions. When asked to set the voltage scales of the oscilloscope, it is important that:
1. The signals fill as much of the vertical scale as possible, for maximum resolution;
2. The signals are not clipped; and
3. The scope is triggering cleanly on the signal.
Not satisfying any of these may lead to suboptimal or erroneus measurements.

The overall conversion gain (in dB) of the subsystem as a function of frequency (i.e. the frequency response of the module) is stored in a file ~bpf.png~. The raw data (frequency, I amplitude, and Q amplitude) is saved in a file ~bpf.txt~.

The resulting frequency response should resemble the plot below. A succesful plot should have the correct corner frequencies as well as sufficient gain as specified in the ICD.
#+html: <p align="center"><img src="PNG/bpf.png" width=800/></p>
** sub-a-mixer.py
This script measures the frequency response of the lowpass filter succeeding the mixer in Subsystem A. It does so by varying the RF input frequency while keeping the LO frequency constant. The RF frequency is sinusoid whose frequency is equal to 14 MHz plus the a low-frequency equal to that of a sinusoidal message signal, which effectively generates an upper sideband RF input signal at the output of the oscilloscope's function generator. In this way, the amplitudes of the I and Q outputs of Subsystem A are proportional to the frequency response of the filter.

The following variables can be modified as you see fit:
- ~fm~ stores a vector of message frequency points to be tested;
- ~input_ampl~ controls the amplitude of wave generator used to excite the ~RF_SIG~ port of Subsystem A. (default: 50 mVpp)

The script runs similarly to ~sub-a-bpf.py~ except that the frequency loop is broken into 3 sub-loops to allow you to adjust the voltage scale if necessary, so that you measure with maximum resolution during each sub-loop.

Several graphs are produced:
1. ~lpf.png~ shows the normalized frequency response of the lowpass filter;
2. ~iq_compare.png~ shows the conversion gain of each channel (I, Q) as a function of the message frequency. Ideally, both responses are identical;
3. ~balance_ampl.png~ and ~balance_phase.png~ show the amplitude and phase balance of the I and Q channels. ~balance_ampl.png~ plots the magnitude of $I/Q$, and ideally should be 0 dB for all frequencies ($|I|=|Q|=1$). ~balance_phase.png~ plots the phase difference between the I and Q channel; ideally, Q should lag I by 90 degrees, i.e. $\angle(I/Q) = -90^\circ$.

Representative plots are shown below. The raw data is also stored in a file ~iq.txt~.
#+html: <p align="center"><img src="PNG/lpf.png" width=800/></p>
#+html: <p align="center"><img src="PNG/iq_compare.png" width=800/></p>
#+html: <p align="center"><img src="PNG/balance_ampl.png" width=800/></p>
#+html: <p align="center"><img src="PNG/balance_phase.png" width=800/></p>
* Subsystem E: sub-e.py
This script carries out various tests on the power amplifier and lowpass filter. It does so by exciting the PA with a fixed-amplitude sinusoidal signal. The amplitude of this signal is controlled by a single variable, ~drive_amplitude~, within the script. It should nominally be set to 1.0 (since the ICD specified the input signal must be 1.0 Vpp), but you can override this if you find your subsystem needs a large amplitude signal in order to work.

The script first measures the current consumption of Subsystem E in the idle and active stages (i.e. with no signal and a 14 MHz signal applied to the input of the PA). From this point, you can change the input frequency if you wish (either from the front panel, or permanently, by modifying the script).

It then conducts an FFT analysis with that signal frequency to determine the amplitudes of the first 5 harmonics produced by the PA, including the fundamental frequency. For example, if the input signal is at 14 MHz, harmonics at 14, 28, 42, 56, and 70 MHz are measured. Output power at the fundamental frequency is reported, along with DC-to-RF power conversion efficiency and the total harmonic distortion of the PA. It is recommended you do *not* increase the input frequency past 14 MHz, because it will be difficult to measure the amplitude of the higher-frequency harmonics (especially $n=5$) due to the limited bandwidth of the oscilloscope.

Finally, the frequency response of the PA is measured between 4-20 MHz by default (this can be overridden by changing the ~freq~ vector if you wish).

Several graphs are produced by this script:
1. ~pout_dBW.png~ plots the output power as a function of frequency in dBW (dB-Watts), defined as $10\log_{10}(P_{out})$, where $P_{out}$ is in W. This is a useful plot because the quantity is intrinsically on a logarithmic scale.
2. ~pout.png~ shows the same thing but with the power output expressed in Watts and plotted in a semi-logarithmic axis, if you are more comfortable reading directly in W.
3. ~spectrum.png~ shows the power spectrum of the harmonics in the output in Watts.

Representative plots are shown below. This data is also saved in two text files: ~pout.txt~ and ~spectrum.txt~.
#+html: <p align="center"><img src="PNG/pout_dBW.png" width=800/></p>
#+html: <p align="center"><img src="PNG/pout.png" width=800/></p>
#+html: <p align="center"><img src="PNG/spectrum.png" width=800/></p>


